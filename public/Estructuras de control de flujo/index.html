
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat." />
        <title>Estructuras de control de flujo</title>
    </head>
    <body>
        <header>
            <a href="/">Go back home</a>
        </header>
        <div class="content">
            <h1>Estructuras de control de flujo</h1>
            <hr />
            <h1 id="estructuras-de-control-de-flujo">Estructuras de control de flujo</h1>
<p>En <em>Haskell</em> contamos con dos formas de estructura condicional y no contamos con ninguna estructura de repetición, sin embargo, contamos con una alternativa.</p>
<h2 id="condicional">Condicional</h2>
<p>La primera forma de estructura condicional es por búsqueda de <em>patrones</em> en los argumentos de la función:</p>
<p>  <code>1 undostres :: Int -&gt; String
  2 undostres 1 = &quot;uno&quot;
  3 undostres 2 = &quot;dos&quot;
  4 undostres 3 = &quot;tres&quot;
  5 undostres x = &quot;otro&quot;
  6
  7  main = do
  8    print(undostres 2)</code>
dos</p>
<p>Esto funciona igual que un &quot;case&quot; o &quot;switch&quot;en otros lenguajes. Los patroness son los números que aparecen como argumentos <strong>1, 2, 3, x</strong>. El argumento de la función se compara por igualdad <strong>=</strong> con cada uno de los &quot;patrones&quot;. Si el argumento es igual a algún patrón, ejecuta y retorna lo que aparece en esa línea después del <strong>=</strong>. Si no es igual a ningún patrón determinado (<strong>1, 2, 3</strong>) ejecuta y retorna lo que aparece con patrón <strong>x</strong>.</p>
<p>La segunda forma de estructura condicional se basa en utilizar &quot;guardas&quot;, representadas por el símbolo <strong>|</strong>:
  <code>1 positivoNegativo :: Int -&gt; String
  2 positivoNegativo :: a
  3   | a &gt; 0        = &quot;positivo&quot;
  4   | a &lt; 0        = &quot;negativo&quot;
  5   | otherwise    = &quot;neutro&quot;
  6
  7 main = do  
  8   print( positivoNegativo 2 )</code>
  positivo</p>
<p>En las líneas 3 y 4 podemos ver cómo se definen 2 resultados para la función <strong>positivoNegativo</strong> basándose en condiciones. Los resultados son aquellos que están después del símbolo <strong>=</strong>. Las condiciones se encuentran previamente en cada línea, entre el símbolo <strong>|</strong> y el <strong>=</strong>. La palabra clave <strong>otherwise</strong> sirve para marcar lo que la función debe devolver en caso de que no se cumpla ninguna de las otras condiciones de las guardas previas.</p>
<h2 id="repetición">Repetición</h2>
<p>Como mencionamos al principio de esta sección, no contamos con estructuras de control, pero contamos con una alternativa más naturalmente cercana al lenguaje funcional: <em>la recursión</em>:
  <code>1 acumular :: [Int] -&gt; Int
  2 acumular [] = 0
  3 acumular  (x:xs) = x + acumular
  4
  5 main = do
  6   print( acumular [5,6,7] )</code></p>
<p>En la línea 2 se define el caso base: cuando se presenta una lista vacía, retorna <strong>0</strong>.</p>
<p>En la línea 3 se puede ver la llamada recursiva. Esta línea se ejecuta solamente cuando el parámetro es distinto a una lista vacía, o sea, cuando el parámetro contiene una lista con al menos un elemento. El formato <strong>(x:xs)</strong> siginifica que en la variable <strong>x</strong> se guarde la cabeza de la lista que está siendo pasada como argumento, y en la variable <strong>xs</strong> el resto de la lista (la cola). Esto quiere decir que para la primer llamada a la función <strong>acumular</strong> con <strong>[5,6,7]</strong>, <strong>x</strong> vale <strong>5</strong> (un <strong>Int</strong>) y <strong>xs</strong> vale <strong>[6,7]</strong> (una lista). Entonces se ejecuta <strong>x + acumular xs</strong> con esos valores, siendo así <strong>5 + acumular [6,7]</strong>. Se llamará a recursión hasta que <strong>xs</strong> sea igual a una lista vacía <strong>[]</strong> con lo que se llega al caso base.</p>

        </div>
    </body>
    </html>
